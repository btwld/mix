// This file is automatically generated. DO NOT EDIT, all your changes would be lost.
//
// DO NOT MODIFY

// ignore_for_file: prefer_relative_imports
import 'dart:ui';

import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';
import 'package:mix/mix.dart';
import 'package:flutter/widgets.dart';
import 'person.attribute.g.dart';

/// A spec for Person.
///
/// To retrieve an instance of [PersonSpec], use the [PersonSpec.of] method with a
/// [BuildContext], or the [PersonSpec.from] method with [MixData]
class PersonSpec extends Spec<PersonSpec> {
  /// Creates a [PersonSpec] with the given fields
  ///
// All parameters are optional
  const PersonSpec({
    this.name,
    this.age,
    this.address,
    this.isEmployed,
    this.height,
    this.hobbies,
    this.favoriteColors,
    this.animated,
  });

  final String? name;

  final int? age;

  final Map<String, String>? address;

  final bool? isEmployed;

  final double? height;

  /// Hobbies of a person
  final Set<String>? hobbies;

  final List<String>? favoriteColors;

  final AnimatedData? animated;

  @override
  PersonSpec copyWith({
    String? name,
    int? age,
    Map<String, String>? address,
    bool? isEmployed,
    double? height,
    Set<String>? hobbies,
    List<String>? favoriteColors,
    AnimatedData? animated,
  }) {
    return PersonSpec(
      name: name ?? this.name,
      age: age ?? this.age,
      address: address ?? this.address,
      isEmployed: isEmployed ?? this.isEmployed,
      height: height ?? this.height,
      hobbies: hobbies ?? this.hobbies,
      favoriteColors: favoriteColors ?? this.favoriteColors,
      animated: animated ?? this.animated,
    );
  }

  @override
  String toString() {
    return 'PersonSpec(name: $name, age: $age, address: $address, isEmployed: $isEmployed, height: $height, hobbies: $hobbies, favoriteColors: $favoriteColors, animated: $animated)';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is PersonSpec &&
        other.name == name &&
        other.age == age &&
        mapEquals(other.address, address) &&
        other.isEmployed == isEmployed &&
        other.height == height &&
        setEquals(other.hobbies, hobbies) &&
        listEquals(other.favoriteColors, favoriteColors) &&
        other.animated == animated;
  }

  @override
  int get hashCode {
    return name.hashCode ^
        age.hashCode ^
        address.hashCode ^
        isEmployed.hashCode ^
        height.hashCode ^
        hobbies.hashCode ^
        favoriteColors.hashCode ^
        animated.hashCode;
  }

  @override
  PersonSpec lerp(
    PersonSpec? other,
    double t,
  ) {
    if (other == null) return this;

    return PersonSpec(
      name: t < 0.5 ? name : other.name,
      age: lerpDouble(age, other.age, t)?.toInt() ?? other.age,
      address: t < 0.5 ? address : other.address,
      isEmployed: t < 0.5 ? isEmployed : other.isEmployed,
      height: lerpDouble(height, other.height, t) ?? other.height,
      hobbies: t < 0.5 ? hobbies : other.hobbies,
      favoriteColors: t < 0.5 ? favoriteColors : other.favoriteColors,
      animated: t < 0.5 ? animated : other.animated,
    );
  }

  /// Retrieves the [PersonSpec] from the nearest [Mix] ancestor.
  ///
  /// If no ancestor is found, returns [PersonSpec].
  static PersonSpec of(BuildContext context) {
    final mix = Mix.of(context);
    return PersonSpec.from(mix);
  }

  /// Retrieves the [PersonSpec] from a MixData.
  ///
  /// returns [PersonSpec].
  static PersonSpec from(MixData mix) {
    return mix.attributeOf<PersonSpecAttribute>()?.resolve(mix) ??
        const PersonSpec();
  }
}

/// A tween that interpolates between two [PersonSpec] instances.
///
/// This class can be used in animations to smoothly transition between
/// different PersonSpec specifications.
class PersonSpecTween extends Tween<PersonSpec?> {
  PersonSpecTween({
    super.begin,
    super.end,
  });

  @override
  PersonSpec lerp(double t) {
    if (begin == null && end == null) return const PersonSpec();
    if (begin == null) return end!;

    return begin!.lerp(end!, t);
  }
}
