import 'package:build/build.dart';
import 'package:code_builder/code_builder.dart';
import 'package:dart_style/dart_style.dart';
import 'package:source_gen/source_gen.dart';

import 'builder_helpers.dart';
import 'spec_definition.dart';

Builder specDefinitionBuilder(BuilderOptions options) =>
    SpecDefinitionBuilder();

class SpecDefinitionBuilder implements Builder {
  final typeChecker = const TypeChecker.fromRuntime(SpecDefinition);
  @override
  Map<String, List<String>> get buildExtensions => {
        '.dart': ['.spec.g.dart', '.util.g.dart', '.attribute.g.dart']
      };

  @override
  Future<void> build(BuildStep buildStep) async {
    final resolver = buildStep.resolver;
    final libraryElement = await resolver.libraryFor(buildStep.inputId);

    final annotatedClasses = libraryElement.units
        .expand((unit) => unit.classes)
        .where((classElement) => typeChecker.hasAnnotationOfExact(classElement))
        .toList();

    for (final classElement in annotatedClasses) {
      final annotation = typeChecker.firstAnnotationOfExact(classElement);
      final baseClassName =
          annotation?.getField('name')?.toStringValue() ?? classElement.name;
      final specClassName = '${baseClassName}Spec';
      final fields = classElement.fields
          .where((field) => !field.isSynthetic)
          .map(FieldInfo.fromElement)
          .toList();

      final constructor = classElement.unnamedConstructor;
      final isConst = constructor?.isConst ?? false;

      final constructorParameters = constructor?.parameters ?? [];
      // Check if any constructor parameter has the `required` keyword
      final hasRequiredParameter =
          constructorParameters.any((parameter) => parameter.isRequiredNamed);
      if (hasRequiredParameter) {
        throw InvalidGenerationSourceError(
          'Spec definition parameters cannot have the `required` keyword.',
          element: constructor,
        );
      }

      // Check if any field is required (non-nullable)
      final hasRequiredField = fields.any((field) => !field.isNullable);
      if (hasRequiredField) {
        throw InvalidGenerationSourceError(
          'All fields of a Spec definition in the class must be nullable.',
          element: classElement,
        );
      }

      final classBuilder = Class((b) {
        b.name = specClassName;
        b.extend = refer('Spec<$specClassName>');
        b.docs.add('/// A spec for $baseClassName.');
        b.docs.add('///');
        b.docs.add(
            '/// To retrieve an instance of [$specClassName], use the [$specClassName.of] method with a');
        b.docs.add(
            '/// [BuildContext], or the [$specClassName.from] method with [MixData]');

        b.fields.addAll(
          fields.map((f) => f.toField()),
        );

        b.constructors.add(
          Constructor((b) => b
            ..constant = isConst
            ..docs.add('/// Creates a [$specClassName] with the given fields')
            ..docs.add('///')
            ..docs.add('// All parameters are optional')
            ..optionalParameters.addAll(
              fields.map((f) => f.toParameter()),
            )),
        );

        b.methods.addAll([
          _generateCopyWithMethod(specClassName, fields),
          _generateToStringMethod(specClassName, fields),
          _generateEqualityOperator(specClassName, fields),
          _generateHashCodeGetter(specClassName, fields),
          _generateLerpMethod(specClassName, fields),
          _generateOfStaticMethod(specClassName),
          _generateFromStaticMethod(specClassName),
        ]);
      });

      final outputSpecId = buildStep.inputId.changeExtension('.spec.g.dart');
      final outputUtilId = buildStep.inputId.changeExtension('.util.g.dart');
      final outputAttributeId =
          buildStep.inputId.changeExtension('.attribute.g.dart');

      final emitter = DartEmitter();
      final format = DartFormatter().format;
      final specFileCode = '''
        // This file is automatically generated. DO NOT EDIT, all your changes would be lost.
        // 
        // DO NOT MODIFY
        
        // ignore_for_file: prefer_relative_imports
        import 'dart:ui';

        import 'package:flutter/foundation.dart';
        import 'package:flutter/widgets.dart';
        import 'package:mix/mix.dart';
        import 'package:flutter/widgets.dart';
        import '${outputAttributeId.pathSegments.last}';

        ${classBuilder.accept(emitter)}

        ${_generateSpecTween(specClassName).accept(emitter)}
      ''';

      final attributeFileCode = '''
        // This file is automatically generated. DO NOT EDIT, all your changes would be lost.
        // 
        // DO NOT MODIFY
        
        // ignore_for_file: prefer_relative_imports
        import 'package:flutter/widgets.dart';
        import 'package:mix/mix.dart';

        import '${outputSpecId.pathSegments.last}';

        ${_generateSpecAttribute(specClassName, fields).accept(emitter)}
        ''';

      await buildStep.writeAsString(outputSpecId, format(specFileCode));
      await buildStep.writeAsString(outputUtilId, '');
      await buildStep.writeAsString(
          outputAttributeId, format(attributeFileCode));
    }
  }
}

Class _generateSpecAttribute(String specClassName, List<FieldInfo> fields) {
  // Map to store the DTO references

  final specAttributeClassName = '${specClassName}Attribute';
  return Class((b) {
    b.name = specAttributeClassName;
    b.extend = refer('SpecAttribute<$specClassName>');
    b.docs.add('/// Represents the attributes of a [$specClassName].');
    b.docs.add('///');
    b.docs
        .add('/// This class encapsulates properties defining the layout and');
    b.docs.add('/// appearance of a [$specClassName].');
    b.docs.add('///');
    b.docs.add(
        '/// Use this class to configure the attributes of a [$specClassName] and pass it to');
    b.docs.add('/// the [$specClassName] constructor.');

    // Fields
    for (var field in fields) {
      b.fields.add(field.toField(dtoType: true));
    }

    // Constructor
    b.constructors.add(
      Constructor(
        (b) => b
          ..constant = true
          ..optionalParameters.addAll(fields.map((field) => Parameter((b) => b
            ..name = field.name
            ..named = true
            ..toThis = true)))
          ..optionalParameters.add(
            Parameter(
              (b) => b
                ..name = 'animated'
                ..named = true
                ..toSuper = true,
            ),
          ),
      ),
    );

    // resolve method
    b.methods.add(Method((b) => b
      ..name = 'resolve'
      ..annotations.add(refer('override'))
      ..returns = refer(specClassName)
      ..requiredParameters.add(Parameter((b) => b
        ..name = 'mix'
        ..type = refer('MixData')))
      ..body = Code('''
        return $specClassName(
          ${fields.map((field) {
        final fieldName = field.name;

        if (field.hasDto) {
          return '$fieldName: $fieldName?.resolve(mix)';
        } else {
          return '$fieldName: $fieldName';
        }
      }).join(', ')},);
      ''')));

    // merge method
    b.methods.add(
      Method(
        (b) => b
          ..name = 'merge'
          ..annotations.add(refer('override'))
          ..returns = refer(specAttributeClassName)
          ..requiredParameters.add(Parameter((b) => b
            ..name = 'other'
            ..type = refer('${specClassName}Attribute?')))
          ..body = Code('''
        if (other == null) return this;

        return $specAttributeClassName(
          ${fields.map((field) {
            final fieldName = field.name;

            if (field.hasDto) {
              return '$fieldName: $fieldName?.merge(other.$fieldName) ?? other.$fieldName';
            } else {
              return '$fieldName: other.$fieldName ?? $fieldName';
            }
          }).join(', ')},);
      '''),
      ),
    );

    // props getter
    b.methods.addAll([
      _generateEqualityOperator(specAttributeClassName, fields),
      _generateHashCodeGetter(specAttributeClassName, fields)
    ]);
  });
}

Method _generateOfStaticMethod(String specClassName) {
  return Method((b) => b
    ..name = 'of'
    ..returns = refer(specClassName)
    ..static = true
    ..requiredParameters.add(Parameter((b) => b
      ..name = 'context'
      ..type = refer('BuildContext')))
    ..docs.add(
        '/// Retrieves the [$specClassName] from the nearest [Mix] ancestor.')
    ..docs.add('///')
    ..docs.add('/// If no ancestor is found, returns [$specClassName].')
    ..body = Code('''
      final mix = Mix.of(context);
      return $specClassName.from(mix);
    '''));
}

Class _generateSpecTween(String specClassName) {
  return Class((b) {
    b.name = '${specClassName}Tween';
    b.extend = refer('Tween<$specClassName?>');
    b.docs.add(
        '/// A tween that interpolates between two [$specClassName] instances.');
    b.docs.add('///');
    b.docs.add(
        '/// This class can be used in animations to smoothly transition between');
    b.docs.add('/// different $specClassName specifications.');

    // Constructor
    b.constructors.add(
      Constructor(
        (b) => b
          ..optionalParameters.addAll([
            Parameter(
              (b) => b
                ..name = 'super.begin'
                ..named = true,
            ),
            Parameter(
              (b) => b
                ..name = 'super.end'
                ..named = true,
            ),
          ]),
      ),
    );

    // lerp method
    b.methods.add(Method((b) => b
      ..name = 'lerp'
      ..annotations.add(refer('override'))
      ..returns = refer(specClassName)
      ..requiredParameters.add(Parameter((b) => b
        ..name = 't'
        ..type = refer('double')))
      ..body = Code('''
              if (begin == null && end == null) return const $specClassName();
              if (begin == null) return end!;
              
              return begin!.lerp(end!, t);
            ''')));
  });
}

Method _generateFromStaticMethod(String specClassName) {
  return Method((b) => b
    ..name = 'from'
    ..returns = refer(specClassName)
    ..static = true
    ..requiredParameters.add(Parameter((b) => b
      ..name = 'mix'
      ..type = refer('MixData')))
    ..docs.add('/// Retrieves the [$specClassName] from a MixData.')
    ..docs.add('///')
    ..docs.add('/// returns [$specClassName].')
    ..body = Code('''
      return mix.attributeOf<${specClassName}Attribute>()?.resolve(mix) ?? const $specClassName();
    '''));
}

Method _generateCopyWithMethod(String className, List<FieldInfo> fields) {
  return Method(
    (b) => b
      ..name = 'copyWith'
      ..annotations.add(refer('override'))
      ..returns = refer(className)
      ..optionalParameters.addAll(fields.map((field) => Parameter((b) => b
        ..name = field.name
        ..named = true
        ..required = false
        ..type = refer('${field.typeRef}?'))))
      ..body = Code('''
          return $className(
            ${fields.map((field) => '${field.name}: ${field.name} ?? this.${field.name}').join(', ')},
          );
        '''),
  );
}

Method _generateToStringMethod(String className, List<FieldInfo> fields) {
  return Method((b) => b
    ..name = 'toString'
    ..annotations.add(refer('override'))
    ..returns = refer('String')
    ..body = Code('''
          return '$className(${fields.map((field) => '${field.name}: \$${field.name}').join(', ')})';
        '''));
}

Method _generateLerpMethod(String className, List<FieldInfo> fields) {
  final lerpStatements = fields.map((field) {
    final fieldName = field.name;
    final fieldType = field.typeRef;

    final lerpSnapDef = 't < 0.5 ? $fieldName : other.$fieldName';
    final lerpIntDef =
        'lerpDouble($fieldName, other.$fieldName, t)?.toInt() ?? other.age';

    String lerpExpression;
    if (fieldType == 'double') {
      lerpExpression =
          'lerpDouble($fieldName, other.$fieldName, t) ?? other.$fieldName';
    } else if (fieldType == 'int') {
      lerpExpression = lerpIntDef;
    } else if (fieldType.startsWith('EdgeInsetsGeometry')) {
      lerpExpression =
          'EdgeInsetsGeometry.lerp($fieldName, other.$fieldName, t)';
    } else if (fieldType.startsWith('BoxConstraints')) {
      lerpExpression = 'BoxConstraints.lerp($fieldName, other.$fieldName, t)';
    } else if (fieldType.startsWith('Decoration')) {
      lerpExpression = 'Decoration.lerp($fieldName, other.$fieldName, t)';
    } else if (fieldType.startsWith('AlignmentGeometry')) {
      lerpExpression =
          'AlignmentGeometry.lerp($fieldName, other.$fieldName, t)';
    } else if (fieldType.startsWith('Matrix4')) {
      lerpExpression =
          'Matrix4Tween(begin: $fieldName, end: other.$fieldName).lerp(t)';
    } else {
      lerpExpression = lerpSnapDef;
    }

    return '$fieldName: $lerpExpression';
  }).join(', ');

  return Method(
    (b) => b
      ..name = 'lerp'
      ..annotations.add(refer('override'))
      ..returns = refer(className)
      ..requiredParameters.addAll([
        Parameter((b) => b
          ..name = 'other'
          ..type = refer('$className?')),
        Parameter((b) => b
          ..name = 't'
          ..type = refer('double')),
      ])
      ..body = Code('''
          if (other == null) return this;

          return $className(
            $lerpStatements,
          );
        '''),
  );
}

Method _generateEqualityOperator(String className, List<FieldInfo> fields) {
  final equalityChecks = fields.map((field) {
    final fieldType = field.type;

    if (fieldType.startsWith('List<')) {
      return 'listEquals(other.${field.name}, ${field.name})';
    } else if (fieldType.startsWith('Map<')) {
      return 'mapEquals(other.${field.name}, ${field.name})';
    } else if (fieldType.startsWith('Set<')) {
      return 'setEquals(other.${field.name}, ${field.name})';
    } else {
      return 'other.${field.name} == ${field.name}';
    }
  }).join(' && ');

  return Method((b) => b
    ..name = 'operator =='
    ..annotations.add(refer('override'))
    ..returns = refer('bool')
    ..requiredParameters.add(Parameter((b) => b
      ..name = 'other'
      ..type = refer('Object')))
    ..body = Code('''
          if (identical(this, other)) return true;

          return other is $className && $equalityChecks;
        '''));
}

Method _generateHashCodeGetter(String className, List<FieldInfo> fields) {
  return Method((b) => b
    ..name = 'hashCode'
    ..annotations.add(refer('override'))
    ..returns = refer('int')
    ..type = MethodType.getter
    ..body = Code('''
          return ${fields.map((field) => '${field.name}.hashCode').join(' ^ ')};
        '''));
}
