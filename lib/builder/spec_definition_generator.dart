import 'package:analyzer/dart/element/element.dart';
import 'package:build/build.dart';
import 'package:code_builder/code_builder.dart';
import 'package:source_gen/source_gen.dart';

import 'spec_definition.dart';

Builder specDefinitionBuilder(BuilderOptions options) => PartBuilder(
      [SpecDefinitionGenerator()],
      '.spec.g.dart',
      additionalOutputExtensions: ['.util.g.dart', '.attribute.g.dart'],
      header: '''
        // This file is automatically generated. DO NOT EDIT, all your changes would be lost.
        // 
        // DO NOT MODIFY
      ''',
      allowSyntaxErrors: false,
    );

class SpecDefinitionGenerator extends GeneratorForAnnotation<SpecDefinition> {
  @override
  generateForAnnotatedElement(
      Element element, ConstantReader annotation, BuildStep buildStep) {
    if (element is! ClassElement) {
      throw InvalidGenerationSourceError(
          'SpecDefinition can only be applied to classes.',
          element: element);
    }

    final className = element.name;
    final specClassName = '${className}Spec';
    final fields = element.fields.where((field) => !field.isSynthetic).toList();

    final classBuilder = Class((b) {
      b.name = specClassName;
      b.extend = refer('Spec<$specClassName>');

      b.fields.addAll(fields.map((field) => Field((b) => b
        ..name = field.name
        ..type = refer(field.type.getDisplayString(withNullability: true))
        ..modifier = FieldModifier.final$)));

      final constructor = element.unnamedConstructor;
      final isConst = constructor?.isConst ?? false;
      final isNamed = constructor?.parameters.first.isNamed ?? false;

      b.constructors.add(Constructor((b) => b
        ..constant = isConst
        ..optionalParameters.addAll(fields.map((field) => Parameter((b) => b
          ..name = field.name
          ..toThis = true
          ..named = isNamed
          ..required = isNamed &&
              constructor!.parameters
                  .firstWhere((p) => p.name == field.name)
                  .isRequiredNamed)))));

      b.methods.addAll([
        _generateCopyWithMethod(specClassName, fields),
        _generateToStringMethod(specClassName, fields),
        _generateEqualityOperator(specClassName, fields),
        _generateHashCodeGetter(specClassName, fields),
        _generateLerpMethod(specClassName, fields),
      ]);
    });

    final emitter = DartEmitter();

    const foundationImport = "import 'package:flutter/foundation.dart';";

    return '''
      $foundationImport

      ${classBuilder.accept(emitter)}
    ''';
  }
}

Method _generateCopyWithMethod(String className, List<FieldElement> fields) {
  return Method((b) => b
    ..name = 'copyWith'
    ..returns = refer(className)
    ..optionalParameters.addAll(fields.map((field) => Parameter((b) => b
      ..name = field.name
      ..named = true
      ..required = false
      ..type =
          refer('${field.type.getDisplayString(withNullability: false)}?'))))
    ..body = Code('''
          return $className(
            ${fields.map((field) => '${field.name}: ${field.name} ?? this.${field.name}').join(', ')}
          );
        '''));
}

Method _generateToStringMethod(String className, List<FieldElement> fields) {
  return Method((b) => b
    ..name = 'toString'
    ..annotations.add(refer('override'))
    ..returns = refer('String')
    ..body = Code('''
          return '$className(${fields.map((field) => '${field.name}: \$${field.name}').join(', ')})';
        '''));
}

Method _generateLerpMethod(String className, List<FieldElement> fields) {
  final lerpStatements = fields.map((field) {
    final fieldName = field.name;
    final fieldType = field.type.getDisplayString(withNullability: true);

    String lerpExpression;
    if (fieldType == 'double') {
      lerpExpression = 'lerpDouble(this.$fieldName, other.$fieldName, t)';
    } else if (fieldType == 'int') {
      lerpExpression = 'lerpInt(this.$fieldName, other.$fieldName, t)';
    } else if (fieldType.startsWith('EdgeInsetsGeometry')) {
      lerpExpression =
          'EdgeInsetsGeometry.lerp(this.$fieldName, other.$fieldName, t)';
    } else if (fieldType.startsWith('BoxConstraints')) {
      lerpExpression =
          'BoxConstraints.lerp(this.$fieldName, other.$fieldName, t)';
    } else if (fieldType.startsWith('Decoration')) {
      lerpExpression = 'Decoration.lerp(this.$fieldName, other.$fieldName, t)';
    } else if (fieldType.startsWith('AlignmentGeometry')) {
      lerpExpression =
          'AlignmentGeometry.lerp(this.$fieldName, other.$fieldName, t)';
    } else if (fieldType.startsWith('Matrix4')) {
      lerpExpression = 'lerpMatrix4(this.$fieldName, other.$fieldName, t)';
    } else if (fieldType.startsWith('Clip')) {
      lerpExpression = 'lerpSnap(this.$fieldName, other.$fieldName, t)';
    } else if (fieldType == 'bool') {
      lerpExpression = 'lerpSnap(this.$fieldName, other.$fieldName, t)';
    } else {
      lerpExpression = 'other.$fieldName';
    }

    return '$fieldName: $lerpExpression';
  }).join(', ');

  return Method((b) => b
    ..name = 'lerp'
    ..annotations.add(refer('override'))
    ..returns = refer(className)
    ..requiredParameters.addAll([
      Parameter((b) => b
        ..name = 'other'
        ..type = refer('$className?')),
      Parameter((b) => b
        ..name = 't'
        ..type = refer('double')),
    ])
    ..body = Code('''
          if (other == null) return this;

          return $className(
            $lerpStatements
          );
        '''));
}

Method _generateEqualityOperator(String className, List<FieldElement> fields) {
  final equalityChecks = fields.map((field) {
    final fieldType = field.type.getDisplayString(withNullability: true);

    if (fieldType.startsWith('List<')) {
      return 'listEquals(other.${field.name}, ${field.name})';
    } else if (fieldType.startsWith('Map<')) {
      return 'mapEquals(other.${field.name}, ${field.name})';
    } else if (fieldType.startsWith('Set<')) {
      return 'setEquals(other.${field.name}, ${field.name})';
    } else {
      return 'other.${field.name} == ${field.name}';
    }
  }).join(' && ');

  return Method((b) => b
    ..name = 'operator =='
    ..annotations.add(refer('override'))
    ..returns = refer('bool')
    ..requiredParameters.add(Parameter((b) => b
      ..name = 'other'
      ..type = refer('Object')))
    ..body = Code('''
          if (identical(this, other)) return true;

          return other is $className && $equalityChecks;
        '''));
}

Method _generateHashCodeGetter(String className, List<FieldElement> fields) {
  return Method((b) => b
    ..name = 'hashCode'
    ..annotations.add(refer('override'))
    ..returns = refer('int')
    ..type = MethodType.getter
    ..body = Code('''
          return ${fields.map((field) => '${field.name}.hashCode').join(' ^ ')};
        '''));
}
