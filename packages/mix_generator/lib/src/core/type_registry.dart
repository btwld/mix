import 'package:analyzer/dart/element/type.dart';
import 'package:logging/logging.dart';

import 'utils/dart_type_utils.dart';
import 'utils/extensions.dart';
import 'utils/string_utils.dart';

/// A simplified registry for managing type mappings using hardcoded maps.
class TypeRegistry {
  static final TypeRegistry instance = TypeRegistry._();

  final Logger _logger = Logger('TypeRegistry');

  // Map to store types discovered during the type discovery phase
  final Map<String, String> _discoveredTypes = {};

  TypeRegistry._();

  /// Helper method to get utility for list types
  String _getUtilityForListType(DartType type) {
    final elementType = type.firstTypeArgument!;
    final elementTypeName =
        getResolvableForType(elementType) ?? elementType.getTypeAsString();

    // If it's a DTO, get the corresponding Flutter type
    String? dartType;
    if (TypeUtils.isResolvable(elementType) && elementType.element != null) {
      final dtoName = elementType.element!.name!;
      // Check if the DTO name exists in the resolvables map
      if (resolvables.containsKey(dtoName)) {
        dartType = resolvables[dtoName]!;
      } else {
        _logger.fine('No Flutter type found for DTO: $dtoName');
      }
    }

    // Construct list type strings for both DTO and Flutter types
    final listTypeString = 'List<$elementTypeName>';
    final flutterListTypeString = dartType != null ? 'List<$dartType>' : null;

    // First check for a direct utility mapping for the list type
    for (final entry in utilities.entries) {
      // Check against both DTO and Flutter type list strings
      if (entry.value == listTypeString) {
        return entry.key;
      }

      if (flutterListTypeString != null &&
          entry.value == flutterListTypeString) {
        return entry.key;
      }
    }

    // Default to generic list utility
    return 'ListUtility<T, $elementTypeName>';
  }

  /// Helper to extract the base type name from a generic type string
  /// For example, 'ImageProvider<Object>' -> 'ImageProvider'
  String _extractBaseTypeName(String typeString) {
    final genericIndex = typeString.indexOf('<');
    if (genericIndex > 0) {
      return typeString.substring(0, genericIndex);
    }

    return typeString;
  }

  /// Returns a map of all currently registered discovered types
  Map<String, String> get allDiscoveredTypes =>
      Map.unmodifiable(_discoveredTypes);

  /// Returns a map of all currently registered utilities
  Map<String, String> get allUtilities => Map.unmodifiable(utilities);

  /// Returns a map of all currently registered resolvables
  Map<String, String> get allResolvables => Map.unmodifiable(resolvables);

  /// Registers types that will be generated
  ///
  /// This is called by the MixableTypeDiscoveryGenerator to pre-register
  /// types that will be generated by other generators.
  void registerDiscoveredTypes(Map<String, String> types) {
    _discoveredTypes.addAll(types);

    // Add discovered types to the resolvables and utilities maps
    types.forEach((generatedType, baseType) {
      if (generatedType.endsWith('Utility')) {
        // Add to utilities map - Utility types map to their base type
        utilities[generatedType] = baseType;
      } else if (generatedType.endsWith('Attribute')) {
        // Add to resolvables map - Attributes map to their Spec class
        resolvables[generatedType] = baseType;
      } else if (generatedType.endsWith('Dto')) {
        // Add to resolvables map - DTOs map to their Flutter type
        final flutterType = baseType;
        resolvables[generatedType] = flutterType;

        // Also add a utility for this DTO if one doesn't already exist
        final utilityName = '${baseType}Utility';
        if (!utilities.containsKey(utilityName)) {
          utilities[utilityName] = baseType;
        }
      }
    });

    _logger.info(
      'Registered ${types.length} discovered types and updated utility/resolvable maps',
    );
  }

  /// Checks if a type has been discovered by the type discovery generator
  bool isDiscoveredType(String typeName) {
    return _discoveredTypes.containsKey(typeName);
  }

  bool hasTryToMerge(String typeName) {
    // If the exact type is in the tryToMerge set
    if (tryToMerge.contains(typeName)) {
      return true;
    }

    // If the type with 'Dto' suffix is in the tryToMerge set
    if (!typeName.endsWith('Dto') && tryToMerge.contains('${typeName}Dto')) {
      return true;
    }

    // If the type without 'Dto' suffix is in the tryToMerge set
    if (typeName.endsWith('Dto')) {
      final baseType = typeName.substring(0, typeName.length - 3);

      return tryToMerge.contains(baseType);
    }

    return false;
  }

  /// Gets the utility type for a DartType
  String getUtilityForType(DartType type) {
    final typeString = type.getTypeAsString();

    // Special handling for Spec types
    if (TypeUtils.isSpec(type)) {
      return '${typeString}Utility';
    }

    // Handle List types specially
    if (type.isList) {
      return _getUtilityForListType(type);
    }

    // Special handling for DTO types in test cases and real code
    if (TypeUtils.isResolvable(type)) {
      final dtoName = type.element!.name!;

      // Special handling for Mixable<T> types
      if (dtoName == 'Mixable' &&
          type is InterfaceType &&
          type.typeArguments.isNotEmpty) {
        final innerType = type.typeArguments.first;
        final innerTypeString = innerType.getTypeAsString();

        // Look for utility for the inner type (e.g., Color for Mixable<Color>)
        for (final entry in utilities.entries) {
          if (entry.value == innerTypeString) {
            return entry.key;
          }
        }
      }

      // Handle DTOs by removing the Dto suffix for utility lookup
      if (dtoName.endsWith('Dto')) {
        final baseName = dtoName.substring(0, dtoName.length - 3);

        return '${baseName}Utility';
      }

      // Just add Utility suffix for non-Dto classes that are resolvable
      return '${dtoName}Utility';
    }

    // For DTO types, get the resolved type for utility mapping in real code
    String resolvedTypeString = typeString;
    if (resolvables.containsKey(typeString)) {
      resolvedTypeString = resolvables[typeString]!;
    }

    // Check for a direct utility mapping using the resolved type
    for (final entry in utilities.entries) {
      if (entry.value == resolvedTypeString) {
        return entry.key;
      }

      // Special handling for generic types like ImageProvider
      // Compare just the base type name without generic parameters
      if (type is InterfaceType) {
        final baseTypeName = type.element.name;
        final entryBaseTypeName = _extractBaseTypeName(entry.value);

        if (baseTypeName == entryBaseTypeName) {
          return entry.key;
        }
      }
    }

    // Check if we have a discovered type
    final utilityName = '${typeString}Utility';
    if (isDiscoveredType(utilityName)) {
      return utilityName;
    }

    // If no mapping found, log warning
    _logger.warning(
      'No utility found for type: $typeString (resolved: $resolvedTypeString), using GenericUtility',
    );

    // Return GenericUtility with the appropriate type parameter instead of DynamicUtility
    return 'GenericUtility<T, $typeString>';
  }

  /// Gets the representation type (DTO or Attribute) for a DartType
  String? getResolvableForType(DartType type) {
    final typeString = type.getTypeAsString();

    // Special handling for Spec types
    if (TypeUtils.isSpec(type)) {
      final typeName = typeString;

      return '${typeName}Attribute';
    }

    if (type.isList) {
      final elementType = type.firstTypeArgument!;
      final valueType = getResolvableForType(elementType);

      if (valueType == null) {
        return null;
      }

      return 'List<$valueType>';
    }

    // Special handling for DTO types
    if (TypeUtils.isResolvable(type)) {
      final typeName = type.element!.name!;

      // Special handling for Mixable<T> - treat it as a resolvable type
      if (typeName == 'Mixable') {
        // Return the typedef name if it's known (e.g., ColorDto for Mixable<Color>)
        if (type is InterfaceType && type.typeArguments.isNotEmpty) {
          final innerType = type.typeArguments.first;
          final innerTypeString = innerType.getTypeAsString();

          // Check if we have a typedef registered for this Mixable<T>
          for (final entry in resolvables.entries) {
            if (entry.value == innerTypeString && entry.key.endsWith('Dto')) {
              return entry.key;
            }
          }
        }
      }

      return typeName;
    }

    // Check for a direct DTO mapping
    for (final dtoEntry in resolvables.entries) {
      if (dtoEntry.value == typeString) {
        return dtoEntry.key;
      }
    }

    // Check in discovered types
    final attributeName = '${typeString}Attribute';
    if (isDiscoveredType(attributeName)) {
      return attributeName;
    }

    // If no specific representation, return the type itself
    return null;
  }

  /// Gets the utility name from a type name string
  String getUtilityNameFromTypeName(String typeName) {
    // Remove Dto or Attribute suffix if present
    if (typeName.endsWith('Dto')) {
      typeName = typeName.substring(0, typeName.length - 3);
    } else if (typeName.endsWith('Attribute')) {
      typeName = typeName.substring(0, typeName.length - 9);
    }

    // Ensure capitalized and add utility suffix
    typeName = typeName.capitalize;

    // Add utility suffix if not present
    if (!typeName.endsWith('Utility')) {
      typeName = '${typeName}Utility';
    }

    return typeName;
  }

  /// Dumps the registry contents to the logger for debugging
  void dumpRegistryContents() {
    _logger.info('=== Type Registry Contents ===');
    _logger.info('Discovered Types: ${_discoveredTypes.length}');
    _logger.info('Utilities: ${utilities.length}');
    _logger.info('Resolvables: ${resolvables.length}');

    _logger.fine('--- Discovered Types ---');
    _discoveredTypes.forEach((key, value) {
      _logger.fine('  $key => $value');
    });

    _logger.fine('--- Utilities ---');
    utilities.forEach((key, value) {
      _logger.fine('  $key => $value');
    });

    _logger.fine('--- Resolvables ---');
    resolvables.forEach((key, value) {
      _logger.fine('  $key => $value');
    });
  }
}

/// Reference to a type by name
class TypeReference {
  final String name;
  final DartType? type;

  const TypeReference(this.name, {this.type});

  static TypeReference fromType(DartType type) =>
      TypeReference(type.getTypeAsString(), type: type);

  @override
  String toString() => 'TypeReference(name: $name, type: ${type ?? ''})';
}

/// List of utility types that should be ignored in certain contexts
final ignoredUtilities = [
  'SpacingSideUtility',
  'FontSizeUtility',
];

/// Map of resolvable class names to their corresponding Flutter type names
final resolvables = {
  'BoxSpecAttribute': 'BoxSpec',
  'ImageSpecAttribute': 'ImageSpec',
  'TextSpecAttribute': 'TextSpec',
  'FlexSpecAttribute': 'FlexSpec',
  'BoxDecorationDto': 'BoxDecoration',
  'AnimationConfigDto': 'AnimationConfig',
  'BoxBorderDto': 'BoxBorder',
  'BorderRadiusGeometryDto': 'BorderRadiusGeometry',
  'BorderSideDto': 'BorderSide',
  'BoxShadowDto': 'BoxShadow',
  'ConstraintsDto': 'Constraints',
  'DecorationDto': 'Decoration',
  'DecorationImageDto': 'DecorationImage',
  'EdgeInsetsGeometryDto': 'EdgeInsetsGeometry',
  'GradientDto': 'Gradient',
  'LinearBorderEdgeDto': 'LinearBorderEdge',
  'OutlinedBorderDto': 'OutlinedBorder',
  'RoundedRectangleBorderDto': 'RoundedRectangleBorder',
  'ShadowDto': 'Shadow',
  'ShapeBorderDto': 'ShapeBorder',
  'SpacingSideDto': 'SpacingSide',
  'StrutStyleDto': 'StrutStyle',
  'TextDirectiveDto': 'TextDirective',
  'TextHeightBehaviorDto': 'TextHeightBehavior',
  'TextStyleDto': 'TextStyle',
  'WidgetModifiersConfigDto': 'WidgetModifiersConfig',
  'WidgetModifiersDataDto': 'WidgetModifiersData',
  'BorderDto': 'Border',
  'BorderRadiusDto': 'BorderRadius',
  'EdgeInsetsDto': 'EdgeInsets',
  'BoxConstraintsDto': 'BoxConstraints',
  // Mixable<T> typedef entries
  'ColorDto': 'Color',
  'RadiusDto': 'Radius',
};

/// Map of utility class names to their corresponding value types
final utilities = {
  'AnimatedUtility': 'AnimationConfig',
  'BoxConstraintsUtility': 'BoxConstraints',
  'BoxDecorationUtility': 'BoxDecoration',
  'BoxShadowListUtility': 'List<BoxShadow>',
  'ColorUtility': 'Color',
  'ColorListUtility': 'List<ColorDto>',
  'ConstraintsUtility': 'Constraints',
  'DecorationUtility': 'Decoration',
  'EdgeInsetsGeometryUtility': 'EdgeInsetsGeometry',
  'GradientUtility': 'Gradient',
  'ListUtility': 'List',
  'ShadowListUtility': 'List<ShadowDto>',
  'SpecModifierUtility': 'WidgetModifiersConfig',
  'ShapeBorderUtility': 'ShapeBorder',
  'SpacingUtility': 'EdgeInsetsGeometry',
  'EdgeInsetsUtility': 'EdgeInsets',
  'TableBorderUtility': 'TableBorder',
  'TextDirectiveUtility': 'TextDirective',
  'WidgetModifiersUtility': 'WidgetModifiersData',
  'BorderRadiusGeometryUtility': 'BorderRadiusGeometry',
  'BorderSideUtility': 'BorderSide',
  'BoxBorderUtility': 'BoxBorder',
  'DecorationImageUtility': 'DecorationImage',
  'LinearBorderEdgeUtility': 'LinearBorderEdge',
  'StrutStyleUtility': 'StrutStyle',
  'TextHeightBehaviorUtility': 'TextHeightBehavior',
  'TextStyleUtility': 'TextStyle',
  'ScrollPhysicsUtility': 'ScrollPhysics',
  'MouseCursorUtility': 'MouseCursor',
};

/// Map of DTO class names to whether they have a tryToMerge method
final tryToMerge = {
  'BoxBorderDto',
  'DecorationDto',
  'EdgeInsetsGeometryDto',
  'GradientDto',
  'ShapeBorderDto',
};
