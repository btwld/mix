# Proof of Concept Implementation

## Overview

This document provides a concrete proof-of-concept implementation showing how the multi-phase type registry would handle nested dependencies in practice.

## Example Scenario

Let's trace through how the system would handle this complex dependency chain:

```dart
// File: lib/specs/box_spec.dart
@MixableSpec()
class BoxSpec extends Spec<BoxSpec> {
  final BoxDecorationDto? decoration;
  final EdgeInsetsDto? padding;
}

// File: lib/dto/box_decoration_dto.dart
@MixableType()
class BoxDecorationDto extends Mixable<BoxDecoration> {
  final ColorDto? color;
  final BorderDto? border;
  final List<BoxShadowDto>? boxShadows;
}

// File: lib/dto/border_dto.dart
@MixableType()
class BorderDto extends Mixable<Border> {
  final BorderSideDto? top;
  final BorderSideDto? bottom;
}

// File: lib/dto/border_side_dto.dart
@MixableType()
class BorderSideDto extends Mixable<BorderSide> {
  final ColorDto? color;
  final double? width;
}

// File: lib/dto/color_dto.dart
@MixableType()
class ColorDto extends Mixable<Color> {
  final int? value;
}
```

## Phase 1: Type Discovery Output

### box_spec.dart.types.json
```json
{
  "BoxSpec": {
    "generatedType": "BoxSpec",
    "baseType": "BoxSpec",
    "category": "spec",
    "sourceFile": "lib/specs/box_spec.dart",
    "discoveryMethod": "annotation",
    "fields": [
      {
        "name": "decoration",
        "type": "BoxDecorationDto",
        "isNullable": true,
        "isGenerated": true
      },
      {
        "name": "padding", 
        "type": "EdgeInsetsDto",
        "isNullable": true,
        "isGenerated": true
      }
    ],
    "generatedComponents": {
      "mixin": true,
      "attribute": true,
      "utility": true
    }
  },
  "BoxSpecAttribute": {
    "generatedType": "BoxSpecAttribute",
    "baseType": "BoxSpec",
    "category": "attribute",
    "sourceFile": "lib/specs/box_spec.dart",
    "discoveryMethod": "annotation"
  },
  "BoxSpecUtility": {
    "generatedType": "BoxSpecUtility", 
    "baseType": "BoxSpec",
    "category": "utility",
    "sourceFile": "lib/specs/box_spec.dart",
    "discoveryMethod": "annotation"
  }
}
```

### box_decoration_dto.dart.types.json
```json
{
  "BoxDecorationDto": {
    "generatedType": "BoxDecorationDto",
    "baseType": "BoxDecoration",
    "category": "dto",
    "sourceFile": "lib/dto/box_decoration_dto.dart",
    "discoveryMethod": "annotation",
    "fields": [
      {
        "name": "color",
        "type": "ColorDto",
        "isNullable": true,
        "isGenerated": true
      },
      {
        "name": "border",
        "type": "BorderDto", 
        "isNullable": true,
        "isGenerated": true
      },
      {
        "name": "boxShadows",
        "type": "List<BoxShadowDto>",
        "isNullable": true,
        "isListType": true,
        "listElementType": "BoxShadowDto",
        "isGenerated": true
      }
    ]
  },
  "BoxDecorationUtility": {
    "generatedType": "BoxDecorationUtility",
    "baseType": "BoxDecoration", 
    "category": "utility",
    "sourceFile": "lib/dto/box_decoration_dto.dart",
    "discoveryMethod": "annotation"
  }
}
```

## Phase 2: Dependency Analysis Output

### box_spec.dart.deps.json
```json
{
  "BoxSpec": {
    "typeName": "BoxSpec",
    "directDependencies": ["BoxDecorationDto", "EdgeInsetsDto"],
    "collectionDependencies": [],
    "optionalDependencies": ["BoxDecorationDto", "EdgeInsetsDto"],
    "dependencyContexts": {
      "BoxDecorationDto": "optional",
      "EdgeInsetsDto": "optional"
    }
  },
  "BoxSpecAttribute": {
    "typeName": "BoxSpecAttribute", 
    "directDependencies": ["BoxDecorationDto", "EdgeInsetsDto"],
    "collectionDependencies": [],
    "optionalDependencies": ["BoxDecorationDto", "EdgeInsetsDto"]
  },
  "BoxSpecUtility": {
    "typeName": "BoxSpecUtility",
    "directDependencies": ["BoxDecorationDto", "EdgeInsetsDto"],
    "collectionDependencies": [],
    "optionalDependencies": ["BoxDecorationDto", "EdgeInsetsDto"]
  }
}
```

### box_decoration_dto.dart.deps.json
```json
{
  "BoxDecorationDto": {
    "typeName": "BoxDecorationDto",
    "directDependencies": ["ColorDto", "BorderDto"],
    "collectionDependencies": ["BoxShadowDto"],
    "optionalDependencies": ["ColorDto", "BorderDto", "BoxShadowDto"],
    "dependencyContexts": {
      "ColorDto": "optional",
      "BorderDto": "optional", 
      "BoxShadowDto": "collection"
    }
  }
}
```

## Phase 3: Generated Type Registry

### lib/generated/type_registry.dart
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by TypeRegistryBuilder

/// Generated type registry containing all discovered Mix types
class GeneratedTypeRegistry {
  /// Complete dependency graph for generation ordering
  static const Map<String, List<String>> dependencyGraph = {
    // Level 0: No dependencies (leaf nodes)
    'ColorDto': [],
    'EdgeInsetsDto': [],
    'BoxShadowDto': [],
    
    // Level 1: Depends only on level 0
    'BorderSideDto': ['ColorDto'],
    
    // Level 2: Depends on level 0-1
    'BorderDto': ['BorderSideDto'],
    
    // Level 3: Depends on level 0-2  
    'BoxDecorationDto': ['ColorDto', 'BorderDto', 'BoxShadowDto'],
    
    // Level 4: Depends on level 0-3
    'BoxSpec': ['BoxDecorationDto', 'EdgeInsetsDto'],
    'BoxSpecAttribute': ['BoxDecorationDto', 'EdgeInsetsDto'],
    'BoxSpecUtility': ['BoxDecorationDto', 'EdgeInsetsDto'],
  };
  
  /// Generation order (topologically sorted)
  static const List<String> generationOrder = [
    // Level 0
    'ColorDto', 'EdgeInsetsDto', 'BoxShadowDto',
    // Level 1  
    'BorderSideDto',
    // Level 2
    'BorderDto',
    // Level 3
    'BoxDecorationDto',
    // Level 4
    'BoxSpec', 'BoxSpecAttribute', 'BoxSpecUtility',
  ];
  
  /// Generation levels for parallel processing
  static const Map<String, int> generationLevels = {
    'ColorDto': 0,
    'EdgeInsetsDto': 0, 
    'BoxShadowDto': 0,
    'BorderSideDto': 1,
    'BorderDto': 2,
    'BoxDecorationDto': 3,
    'BoxSpec': 4,
    'BoxSpecAttribute': 4,
    'BoxSpecUtility': 4,
  };
  
  /// Map of utility class names to their corresponding value types
  static const Map<String, String> utilities = {
    'ColorUtility': 'Color',
    'EdgeInsetsUtility': 'EdgeInsets',
    'BoxShadowUtility': 'BoxShadow',
    'BorderSideUtility': 'BorderSide',
    'BorderUtility': 'Border',
    'BoxDecorationUtility': 'BoxDecoration',
    'BoxSpecUtility': 'BoxSpec',
  };
  
  /// Map of resolvable class names to their corresponding Flutter type names
  static const Map<String, String> resolvables = {
    'ColorDto': 'Color',
    'EdgeInsetsDto': 'EdgeInsets',
    'BoxShadowDto': 'BoxShadow', 
    'BorderSideDto': 'BorderSide',
    'BorderDto': 'Border',
    'BoxDecorationDto': 'BoxDecoration',
    'BoxSpecAttribute': 'BoxSpec',
  };
  
  /// Set of DTO class names that have tryToMerge capability
  static const Set<String> tryToMergeTypes = {
    'BoxDecorationDto',
    'BorderDto',
    'EdgeInsetsDto',
  };
  
  /// All discovered types with their metadata
  static const Map<String, String> discoveredTypes = {
    'ColorDto': 'Color',
    'ColorUtility': 'Color',
    'EdgeInsetsDto': 'EdgeInsets',
    'EdgeInsetsUtility': 'EdgeInsets',
    'BoxShadowDto': 'BoxShadow',
    'BoxShadowUtility': 'BoxShadow',
    'BorderSideDto': 'BorderSide', 
    'BorderSideUtility': 'BorderSide',
    'BorderDto': 'Border',
    'BorderUtility': 'Border',
    'BoxDecorationDto': 'BoxDecoration',
    'BoxDecorationUtility': 'BoxDecoration',
    'BoxSpec': 'BoxSpec',
    'BoxSpecAttribute': 'BoxSpec',
    'BoxSpecUtility': 'BoxSpec',
  };
  
  /// Get utility type for a given type string
  static String? getUtilityForType(String typeString) {
    // Check direct mapping
    for (final entry in utilities.entries) {
      if (entry.value == typeString) {
        return entry.key;
      }
    }
    
    // Check discovered types
    final utilityName = '${typeString}Utility';
    if (discoveredTypes.containsKey(utilityName)) {
      return utilityName;
    }
    
    return null;
  }
  
  /// Get resolvable type for a given type string
  static String? getResolvableForType(String typeString) {
    // Check direct mapping
    for (final entry in resolvables.entries) {
      if (entry.value == typeString) {
        return entry.key;
      }
    }
    
    return null;
  }
  
  /// Check if type has tryToMerge capability
  static bool hasTryToMerge(String typeName) {
    return tryToMergeTypes.contains(typeName) ||
           tryToMergeTypes.contains('${typeName}Dto');
  }
  
  /// Get generation batches for parallel processing
  static List<List<String>> getGenerationBatches() {
    final batches = <List<String>>[];
    final maxLevel = generationLevels.values.reduce((a, b) => a > b ? a : b);
    
    for (int level = 0; level <= maxLevel; level++) {
      final batch = generationOrder
          .where((type) => generationLevels[type] == level)
          .toList();
      if (batch.isNotEmpty) {
        batches.add(batch);
      }
    }
    
    return batches;
  }
}
```

## Phase 4: Updated Main Generator Usage

```dart
class MixMainGenerator extends Generator {
  @override
  String generate(LibraryReader library, BuildStep buildStep) {
    // Use generated registry instead of TypeRegistry.instance
    final buffer = StringBuffer();
    
    // Get generation order for this library's types
    final libraryTypes = _getLibraryTypes(library);
    final orderedTypes = _getGenerationOrder(libraryTypes);
    
    // Generate in dependency order
    for (final typeName in orderedTypes) {
      final metadata = _getMetadataForType(typeName);
      if (metadata != null) {
        _generateTypeCode(metadata, buffer);
      }
    }
    
    return buffer.toString();
  }
  
  List<String> _getGenerationOrder(List<String> libraryTypes) {
    // Filter global generation order to only include types in this library
    return GeneratedTypeRegistry.generationOrder
        .where((type) => libraryTypes.contains(type))
        .toList();
  }
  
  String getUtilityForType(DartType type) {
    final typeString = type.getTypeAsString();
    
    // Use generated registry instead of hardcoded maps
    final utility = GeneratedTypeRegistry.getUtilityForType(typeString);
    if (utility != null) {
      return utility;
    }
    
    return 'GenericUtility<T, $typeString>';
  }
}
```

## Benefits Demonstrated

1. **Eliminates Circular Dependencies**: Types are generated in correct dependency order
2. **Handles Nested Dependencies**: Complex chains like `BoxSpec -> BoxDecorationDto -> BorderDto -> BorderSideDto -> ColorDto` work correctly
3. **No Hardcoded Maps**: All type mappings are discovered and generated
4. **Parallel Processing**: Types at the same level can be generated in parallel
5. **Incremental Builds**: Only affected types are regenerated when dependencies change

This proof-of-concept shows that the multi-phase approach can successfully handle complex nested dependencies while eliminating the circular dependency problem in your current system.
