---
title: "Utilities Fundamentals"
---

# Utility-First Approach

<<<<<<< HEAD
Mix embraces a **utility-first styling model** through the **Styler API**.  
A *styler* (such as `BoxStyler`) provides small, composable utilities—like `color`, `border`, `borderRadius`, or `padding`—that you combine to express the style you need.

This approach promotes:

- **Declarative Semantic** — Facilitates meaningful and easily understandable styling for widgets.
- **Composability** — freely combine, conditionally apply, or reuse utilities across contexts.
- **Efficiency** — simple, chainable methods and reusability reduce boilerplate.
- **Flexibility** — build modular UIs without being locked into rigid abstractions.

---

## Example: Building Styles

`Styler` methods are descriptive, predictable, and easy to chain. For example:

```dart
final boxStyle = BoxStyler()
  .width(100)
  .paddingAll(10)
  .alignment(Alignment.center)
  .color(Colors.red);
```

The example above shows how you can build up a style step by step using the **builder design pattern**. Each method—like `.width(100)` or `.color(Colors.red)`—adds a style property, and you can chain them together. This makes it easy to create and reuse styles in a clear and readable way.

## Intuitive and Familiar API

Mix's API is designed to be intuitive and easy to pick up, especially for Flutter developers. The method names and patterns closely follow those established by Flutter itself, making the API both easy to understand and predict.

```dart
// Explicit alignment
BoxStyler().alignment(Alignment.centerRight);

// Spacing helpers
BoxStyler().paddingAll(16); // All sides
BoxStyler().paddingX(12).paddingY(8); // Horizontal and vertical
BoxStyler().paddingOnly(horizontal: 12, vertical: 8); // Specific sides
```

## Styler helpers (aliases)

Create small helper functions or variables to reuse common styler patterns.

### Example

Direct border methods are available on the styler.

```dart
// Red border on all sides
BoxStyler().borderAll(color: Colors.red);

// Top border only with custom width
BoxStyler().borderTop(color: Colors.red, width: 2);
```

### Creating helpers



You can create your own shorthand by either defining small helper functions that return a `BoxStyler`, or by extending `BoxStyler` with your own extension methods:

```dart
// Custom helper for border top styling
BoxStyler borderTop(Color color) => BoxStyler().borderTop(color: color);

// Use the helper
borderTop(Colors.red);

// Extension method
extension on BoxStyler {
  BoxStyler borderRedTop() => borderTop(color: Colors.red);
}

// Use the extension method
BoxStyler().borderRedTop();
```
=======
Mix Utilities are essential for efficient and intuitive styling. This functional approach not only enhances the consistency of UI designs but also ensures a more intuitive styling process.

## Key Concept

The Utility-First Approach focuses on crafting small, reusable style components like color variations, borders, radii, and spacing. These components can be seamlessly combined to form complex styles. This method encourages a modular approach to UI development, significantly reducing code duplication and enhancing flexibility.

## Purpose & Benefits

- **Semantic Consistency**: Facilitates meaningful and easily understandable styling for widgets.
- **Increased Efficiency**: Streamlines development by simplifying code and improving maintainability.
- **Enhanced Control**: Offers greater command over styling, enabling better composability and integration of design elements.

## Descriptive Styling

Utilities are designed to be descriptive and easy to understand. This makes it easy to know what each utility does and how to use it.

```dart
final style = Style(
  $box.width(100),
  $box.padding(10),
  $box.alignment.center(),
  $box.color.red(),
);
```

## Intuitive API design

A utility is a class that mimics the functionality of a method. This allows you to use utilities in a way that feels natural and intuitive.

There are many ways to use a utility to achieve the same result. They are typically used for different purposes, but they all achieve the same result, and you can use the one that makes the most sense for you.

```dart
// Chaining style is the most common way to use utilities.
$box.alignment.center();

// As this seems similar to the above, this allows you to pass an `Alignment` as a parameter.
$box.alignment(Alignment.center);

// Gives you direct control over the `x` and `y` values of an `Alignment` object.
$box.alignment.only(x: 0.0, y: 0.0);
```

## Utility Aliases

Aliases are utilities that are meant to be used as a shorthand for other utilities, or provide a shortcut to a nested utility path.

### Example

`$box.border` is an alias to `$box.decoration.border`. This allows you to use `$box.border` instead of `$box.decoration.border` to apply a border to a widget.

```dart
// A utility to define a box border.
$box.border.color.red();

// The same as
$box.decoration.border.color.red();
```

### Creating aliases

If you want to create your own shorthand utilities, you can just assign the utility to a variable. For instance:

```dart
// Custom alias for border top styling
final bt = $box.border.top;

// As a method
bt.color.red();

// As a paramter
bt(color: Colors.red);
```

You can also create aliases for specific values of a utility. For example:

```dart
// Custom alias for border.top.color.red
final borderRedTop = $box.border.top.color.red;

// Usage
borderRedTop();
```
>>>>>>> next
